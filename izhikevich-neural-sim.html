<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Izhikevich„Éã„É•„Éº„É©„É´„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Ç∑„Éü„É•„É¨„Éº„Çø„Éº</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #0a0a0a;
            color: #e0e0e0;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            color: #4a9eff;
            margin-bottom: 30px;
            font-size: 2em;
            text-shadow: 0 0 20px rgba(74, 158, 255, 0.5);
        }
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-bottom: 20px;
        }
        .canvas-container {
            background: #1a1a1a;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        canvas {
            border: 1px solid #333;
            border-radius: 5px;
            display: block;
            margin: 0 auto;
            cursor: crosshair;
        }
        .controls {
            background: #1a1a1a;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        .control-group {
            margin-bottom: 20px;
            padding: 15px;
            background: #252525;
            border-radius: 8px;
            border: 1px solid #333;
        }
        .control-group h3 {
            margin-top: 0;
            color: #4a9eff;
            font-size: 1.1em;
        }
        label {
            display: block;
            margin-bottom: 5px;
            color: #b0b0b0;
            font-size: 0.9em;
        }
        select, input[type="range"], input[type="number"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            background: #333;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
        }
        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #4a9eff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
        }
        button:hover {
            background: #5aafff;
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(74, 158, 255, 0.3);
        }
        button:active {
            transform: translateY(0);
        }
        .danger {
            background: #ff4a4a;
        }
        .danger:hover {
            background: #ff5a5a;
        }
        .info-panel {
            background: #1a1a1a;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        .neuron-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .neuron-card {
            background: #252525;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            transition: all 0.3s;
        }
        .neuron-card:hover {
            border-color: #4a9eff;
            box-shadow: 0 0 15px rgba(74, 158, 255, 0.2);
        }
        .neuron-card h4 {
            margin: 0 0 10px 0;
            color: #4a9eff;
        }
        .neuron-card p {
            margin: 5px 0;
            font-size: 0.9em;
            color: #b0b0b0;
        }
        .spike-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #333;
            margin-left: 10px;
            transition: all 0.1s;
        }
        .spike-indicator.active {
            background: #ff4a4a;
            box-shadow: 0 0 10px #ff4a4a;
        }
        .legend {
            margin-top: 15px;
            padding: 15px;
            background: #252525;
            border-radius: 8px;
            border: 1px solid #333;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 10px;
        }
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        .stat-item {
            background: #333;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .stat-value {
            font-size: 1.2em;
            color: #4a9eff;
            font-weight: bold;
        }
        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .mode-button {
            flex: 1;
            padding: 8px;
            background: #333;
            border: 2px solid #444;
            color: #b0b0b0;
            cursor: pointer;
            transition: all 0.3s;
        }
        .mode-button.active {
            background: #4a9eff;
            border-color: #4a9eff;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß† Izhikevich„Éã„É•„Éº„É©„É´„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Ç∑„Éü„É•„É¨„Éº„Çø„Éº</h1>
        
        <div class="main-grid">
            <div class="canvas-container">
                <canvas id="networkCanvas" width="800" height="600"></canvas>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <h3>Á∑®ÈõÜ„É¢„Éº„Éâ</h3>
                    <div class="mode-selector">
                        <button class="mode-button active" data-mode="neuron">„Éã„É•„Éº„É≠„É≥</button>
                        <button class="mode-button" data-mode="synapse">„Ç∑„Éä„Éó„Çπ</button>
                        <button class="mode-button" data-mode="delete">ÂâäÈô§</button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>„Éã„É•„Éº„É≠„É≥„Çø„Ç§„Éó</h3>
                    <select id="neuronType">
                        <option value="RS">Regular Spiking (RS)</option>
                        <option value="IB">Intrinsically Bursting (IB)</option>
                        <option value="FS">Fast Spiking (FS)</option>
                        <option value="LTS">Low-Threshold Spiking (LTS)</option>
                        <option value="CH">Chattering (CH)</option>
                    </select>
                </div>

                <div class="control-group">
                    <h3>„Ç∑„Éä„Éó„Çπ„Çø„Ç§„Éó</h3>
                    <select id="synapseType">
                        <option value="excitatory">ËààÂ•ÆÊÄß (Excitatory)</option>
                        <option value="inhibitory">ÊäëÂà∂ÊÄß (Inhibitory)</option>
                    </select>
                    <label>„Ç∑„Éä„Éó„ÇπÂº∑Â∫¶</label>
                    <input type="range" id="synapseStrength" min="0" max="20" value="10" step="0.5">
                    <span id="strengthValue">10</span>
                </div>

                <div class="control-group">
                    <h3>Â§ñÈÉ®ÈõªÊµÅ</h3>
                    <label>ÈõªÊµÅÂº∑Â∫¶ (pA)</label>
                    <input type="range" id="currentStrength" min="0" max="50" value="10" step="1">
                    <span id="currentValue">10</span>
                </div>

                <div class="control-group">
                    <h3>„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Âà∂Âæ°</h3>
                    <button id="startBtn">‚ñ∂Ô∏è ÈñãÂßã</button>
                    <button id="pauseBtn">‚è∏Ô∏è ‰∏ÄÊôÇÂÅúÊ≠¢</button>
                    <button id="resetBtn" class="danger">üîÑ „É™„Çª„ÉÉ„Éà</button>
                </div>

                <div class="legend">
                    <h4>Âá°‰æã</h4>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00ff00;"></div>
                        <span>ËààÂ•ÆÊÄß„Ç∑„Éä„Éó„Çπ</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff00ff;"></div>
                        <span>ÊäëÂà∂ÊÄß„Ç∑„Éä„Éó„Çπ</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <h3>„Éã„É•„Éº„É≠„É≥ÊÉÖÂ†±</h3>
            <div id="neuronInfo" class="neuron-info"></div>
            <div class="stats">
                <div class="stat-item">
                    <div>Á∑è„Éã„É•„Éº„É≠„É≥Êï∞</div>
                    <div class="stat-value" id="totalNeurons">0</div>
                </div>
                <div class="stat-item">
                    <div>Á∑è„Ç∑„Éä„Éó„ÇπÊï∞</div>
                    <div class="stat-value" id="totalSynapses">0</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Izhikevich„É¢„Éá„É´„ÅÆ„Éë„É©„É°„Éº„ÇøÂÆöÁæ©
        const neuronParams = {
            RS: { a: 0.02, b: 0.2, c: -65, d: 8, name: "Regular Spiking" },
            IB: { a: 0.02, b: 0.2, c: -55, d: 4, name: "Intrinsically Bursting" },
            FS: { a: 0.1, b: 0.2, c: -65, d: 2, name: "Fast Spiking" },
            LTS: { a: 0.02, b: 0.25, c: -65, d: 2, name: "Low-Threshold Spiking" },
            CH: { a: 0.02, b: 0.2, c: -50, d: 2, name: "Chattering" }
        };

        class Neuron {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.params = neuronParams[type];
                this.v = -65;  // ËÜúÈõª‰Ωç
                this.u = this.params.b * this.v;  // ÂõûÂæ©Â§âÊï∞
                this.I = 0;  // ÂÖ•ÂäõÈõªÊµÅ
                this.spiked = false;
                this.spikeHistory = [];
                this.id = Date.now() + Math.random();
            }

            update(dt, externalCurrent) {
                // Izhikevich„É¢„Éá„É´„ÅÆÊï∞ÂÄ§Á©çÂàÜ
                const dv = 0.04 * this.v * this.v + 5 * this.v + 140 - this.u + this.I + externalCurrent;
                const du = this.params.a * (this.params.b * this.v - this.u);
                
                this.v += dv * dt;
                this.u += du * dt;
                
                // „Çπ„Éë„Ç§„ÇØÊ§úÂá∫„Å®„É™„Çª„ÉÉ„Éà
                if (this.v >= 30) {
                    this.v = this.params.c;
                    this.u += this.params.d;
                    this.spiked = true;
                    this.spikeHistory.push(Date.now());
                    // Âè§„ÅÑ„Çπ„Éë„Ç§„ÇØÂ±•Ê≠¥„ÇíÂâäÈô§
                    const now = Date.now();
                    this.spikeHistory = this.spikeHistory.filter(t => now - t < 5000);
                } else {
                    this.spiked = false;
                }
                
                // „Ç∑„Éä„Éó„ÇπÈõªÊµÅ„ÅÆÊ∏õË°∞
                this.I *= 0.95;
            }

            receiveInput(current) {
                this.I += current;
            }

            getFireRate() {
                // ÈÅéÂéª5ÁßíÈñì„ÅÆÁô∫ÁÅ´Áéá„ÇíË®àÁÆó
                const now = Date.now();
                const recentSpikes = this.spikeHistory.filter(t => now - t < 5000);
                return recentSpikes.length / 5;  // Hz
            }
        }

        class Synapse {
            constructor(preNeuron, postNeuron, type, strength) {
                this.pre = preNeuron;
                this.post = postNeuron;
                this.type = type;  // 'excitatory' or 'inhibitory'
                this.strength = strength;
                this.delay = 1;  // „Ç∑„Éä„Éó„ÇπÈÅÖÂª∂ (ms)
                this.id = Date.now() + Math.random();
            }

            transmit() {
                if (this.pre.spiked) {
                    const current = this.type === 'excitatory' ? this.strength : -this.strength;
                    setTimeout(() => {
                        this.post.receiveInput(current);
                    }, this.delay);
                }
            }
        }

        class NeuralNetwork {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.neurons = [];
                this.synapses = [];
                this.running = false;
                this.editMode = 'neuron';
                this.selectedNeuron = null;
                this.dt = 0.5;  // ÊôÇÈñì„Çπ„ÉÜ„ÉÉ„Éó (ms)
                
                this.setupEventListeners();
                this.animate();
            }

            setupEventListeners() {
                // „É¢„Éº„ÉâÂàáÊõø
                document.querySelectorAll('.mode-button').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.mode-button').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.editMode = e.target.dataset.mode;
                        this.selectedNeuron = null;
                    });
                });

                // „Ç≠„É£„É≥„Éê„Çπ„ÇØ„É™„ÉÉ„ÇØ
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    if (this.editMode === 'neuron') {
                        const type = document.getElementById('neuronType').value;
                        this.addNeuron(x, y, type);
                    } else if (this.editMode === 'synapse') {
                        const clickedNeuron = this.getNeuronAt(x, y);
                        if (clickedNeuron) {
                            if (!this.selectedNeuron) {
                                this.selectedNeuron = clickedNeuron;
                            } else if (clickedNeuron !== this.selectedNeuron) {
                                const type = document.getElementById('synapseType').value;
                                const strength = parseFloat(document.getElementById('synapseStrength').value);
                                this.addSynapse(this.selectedNeuron, clickedNeuron, type, strength);
                                this.selectedNeuron = null;
                            }
                        }
                    } else if (this.editMode === 'delete') {
                        const neuron = this.getNeuronAt(x, y);
                        if (neuron) {
                            this.removeNeuron(neuron);
                        } else {
                            const synapse = this.getSynapseAt(x, y);
                            if (synapse) {
                                this.removeSynapse(synapse);
                            }
                        }
                    }
                    
                    this.updateStats();
                });

                // „Ç≥„É≥„Éà„É≠„Éº„É´
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('pauseBtn').addEventListener('click', () => this.pause());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());

                // „Çπ„É©„Ç§„ÉÄ„Éº
                document.getElementById('synapseStrength').addEventListener('input', (e) => {
                    document.getElementById('strengthValue').textContent = e.target.value;
                });
                document.getElementById('currentStrength').addEventListener('input', (e) => {
                    document.getElementById('currentValue').textContent = e.target.value;
                });
            }

            addNeuron(x, y, type) {
                this.neurons.push(new Neuron(x, y, type));
            }

            addSynapse(pre, post, type, strength) {
                // ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
                const exists = this.synapses.some(s => s.pre === pre && s.post === post);
                if (!exists) {
                    this.synapses.push(new Synapse(pre, post, type, strength));
                }
            }

            removeNeuron(neuron) {
                // Èñ¢ÈÄ£„Åô„Çã„Ç∑„Éä„Éó„Çπ„ÇÇÂâäÈô§
                this.synapses = this.synapses.filter(s => s.pre !== neuron && s.post !== neuron);
                this.neurons = this.neurons.filter(n => n !== neuron);
            }

            removeSynapse(synapse) {
                this.synapses = this.synapses.filter(s => s !== synapse);
            }

            getNeuronAt(x, y) {
                const radius = 20;
                return this.neurons.find(n => {
                    const dx = n.x - x;
                    const dy = n.y - y;
                    return dx * dx + dy * dy <= radius * radius;
                });
            }

            getSynapseAt(x, y) {
                const threshold = 10;
                return this.synapses.find(s => {
                    const dist = this.pointToLineDistance(x, y, s.pre.x, s.pre.y, s.post.x, s.post.y);
                    return dist < threshold;
                });
            }

            pointToLineDistance(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                
                if (lenSq !== 0) param = dot / lenSq;
                
                let xx, yy;
                
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                
                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }

            update() {
                if (!this.running) return;
                
                const externalCurrent = parseFloat(document.getElementById('currentStrength').value);
                
                // „Éã„É•„Éº„É≠„É≥„ÅÆÊõ¥Êñ∞
                this.neurons.forEach(neuron => {
                    neuron.update(this.dt, externalCurrent);
                });
                
                // „Ç∑„Éä„Éó„Çπ‰ºùÈÅî
                this.synapses.forEach(synapse => {
                    synapse.transmit();
                });
                
                this.updateNeuronInfo();
            }

            draw() {
                this.ctx.fillStyle = '#0a0a0a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // „Ç∞„É™„ÉÉ„ÉâÊèèÁîª
                this.drawGrid();
                
                // „Ç∑„Éä„Éó„ÇπÊèèÁîª
                this.synapses.forEach(synapse => {
                    this.ctx.save();
                    
                    // „Ç∑„Éä„Éó„Çπ„ÅÆËâ≤ÔºàHueÔºâ
                    const hue = synapse.type === 'excitatory' ? 120 : 300;  // Á∑ë:ËààÂ•ÆÊÄß„ÄÅÁ¥´:ÊäëÂà∂ÊÄß
                    this.ctx.strokeStyle = `hsl(${hue}, 70%, 50%)`;
                    this.ctx.lineWidth = 2;
                    
                    // Áü¢Âç∞„ÅÆÊèèÁîª
                    this.drawArrow(synapse.pre.x, synapse.pre.y, synapse.post.x, synapse.post.y);
                    
                    this.ctx.restore();
                });
                
                // „Éã„É•„Éº„É≠„É≥ÊèèÁîª
                this.neurons.forEach(neuron => {
                    this.ctx.save();
                    
                    // ËÜúÈõª‰Ωç„Å´„Çà„ÇãÊòéÂ∫¶Ë™øÊï¥
                    const brightness = Math.max(0, Math.min(100, (neuron.v + 80) / 110 * 100));
                    const hue = neuron.type === 'FS' ? 200 : 220;  // FS„Éã„É•„Éº„É≠„É≥„ÅØÂ∞ë„ÅóÈÅï„ÅÜËâ≤Áõ∏
                    
                    // „Çπ„Éë„Ç§„ÇØÊôÇ„ÅÆÂäπÊûú
                    if (neuron.spiked) {
                        this.ctx.shadowBlur = 30;
                        this.ctx.shadowColor = '#ff4a4a';
                    }
                    
                    this.ctx.fillStyle = `hsl(${hue}, 70%, ${brightness}%)`;
                    this.ctx.strokeStyle = this.selectedNeuron === neuron ? '#4a9eff' : '#444';
                    this.ctx.lineWidth = this.selectedNeuron === neuron ? 3 : 2;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(neuron.x, neuron.y, 20, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.stroke();
                    
                    // „Éã„É•„Éº„É≠„É≥„Çø„Ç§„ÉóË°®Á§∫
                    this.ctx.fillStyle = brightness > 50 ? '#000' : '#fff';
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(neuron.type, neuron.x, neuron.y);
                    
                    this.ctx.restore();
                });
            }

            drawGrid() {
                this.ctx.strokeStyle = '#1a1a1a';
                this.ctx.lineWidth = 1;
                
                for (let x = 0; x < this.canvas.width; x += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }

            drawArrow(x1, y1, x2, y2) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                const angle = Math.atan2(dy, dx);
                const length = Math.sqrt(dx * dx + dy * dy);
                
                // Áü¢Âç∞„Çí„Éã„É•„Éº„É≠„É≥„ÅÆÂ¢ÉÁïå„ÅßÊ≠¢„ÇÅ„Çã
                const startOffset = 20;
                const endOffset = 20;
                const adjustedLength = length - startOffset - endOffset;
                
                const startX = x1 + Math.cos(angle) * startOffset;
                const startY = y1 + Math.sin(angle) * startOffset;
                const endX = startX + Math.cos(angle) * adjustedLength;
                const endY = startY + Math.sin(angle) * adjustedLength;
                
                // Á∑ö„ÇíÊèèÁîª
                this.ctx.beginPath();
                this.ctx.moveTo(startX, startY);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();
                
                // Áü¢Âç∞„ÅÆÈ†≠„ÇíÊèèÁîª
                const arrowSize = 10;
                this.ctx.beginPath();
                this.ctx.moveTo(endX, endY);
                this.ctx.lineTo(
                    endX - arrowSize * Math.cos(angle - Math.PI / 6),
                    endY - arrowSize * Math.sin(angle - Math.PI / 6)
                );
                this.ctx.moveTo(endX, endY);
                this.ctx.lineTo(
                    endX - arrowSize * Math.cos(angle + Math.PI / 6),
                    endY - arrowSize * Math.sin(angle + Math.PI / 6)
                );
                this.ctx.stroke();
            }

            updateNeuronInfo() {
                const infoDiv = document.getElementById('neuronInfo');
                infoDiv.innerHTML = '';
                
                this.neurons.forEach((neuron, index) => {
                    const card = document.createElement('div');
                    card.className = 'neuron-card';
                    card.innerHTML = `
                        <h4>„Éã„É•„Éº„É≠„É≥ ${index + 1} (${neuron.type})</h4>
                        <p>ËÜúÈõª‰Ωç: ${neuron.v.toFixed(1)} mV</p>
                        <p>ÂõûÂæ©Â§âÊï∞ u: ${neuron.u.toFixed(1)}</p>
                        <p>Áô∫ÁÅ´Áéá: ${neuron.getFireRate().toFixed(1)} Hz
                            <span class="spike-indicator ${neuron.spiked ? 'active' : ''}"></span>
                        </p>
                    `;
                    infoDiv.appendChild(card);
                });
            }

            updateStats() {
                document.getElementById('totalNeurons').textContent = this.neurons.length;
                document.getElementById('totalSynapses').textContent = this.synapses.length;
            }

            animate() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.animate());
            }

            start() {
                this.running = true;
            }

            pause() {
                this.running = false;
            }

            reset() {
                this.neurons = [];
                this.synapses = [];
                this.selectedNeuron = null;
                this.running = false;
                this.updateStats();
                document.getElementById('neuronInfo').innerHTML = '';
            }
        }

        // ÂàùÊúüÂåñ
        const canvas = document.getElementById('networkCanvas');
        const network = new NeuralNetwork(canvas);

        // „Éá„É¢„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„ÅÆ‰ΩúÊàê
        function createDemoNetwork() {
            // ‰∏≠Â§Æ„Å´ÂÜÜÂΩ¢ÈÖçÁΩÆ
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 150;
            const types = ['RS', 'IB', 'FS', 'LTS', 'CH'];
            
            const neurons = [];
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                network.addNeuron(x, y, types[i]);
                neurons.push(network.neurons[network.neurons.length - 1]);
            }
            
            // „É©„É≥„ÉÄ„É†„Å™„Ç∑„Éä„Éó„ÇπÁµêÂêà
            for (let i = 0; i < neurons.length; i++) {
                for (let j = 0; j < neurons.length; j++) {
                    if (i !== j && Math.random() < 0.3) {
                        const type = Math.random() < 0.7 ? 'excitatory' : 'inhibitory';
                        const strength = 5 + Math.random() * 10;
                        network.addSynapse(neurons[i], neurons[j], type, strength);
                    }
                }
            }
            
            network.updateStats();
        }

        // ÂàùÊúü„Éá„É¢„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ
        createDemoNetwork();
    </script>
</body>
</html>